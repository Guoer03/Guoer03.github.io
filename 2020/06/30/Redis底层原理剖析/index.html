<!DOCTYPE html>
<html lang="java">


<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>
    Redis底层原理剖析 | Guoer03的学习笔记
  </title>
  <meta name="description" content="java后端，人工智能">
  
  <meta name="keywords" content="
  java相关,缓存
  ">
  
  <meta name="author" content="Arthur Ming">

  <meta http-equiv="Cache-Control" content="no-transform"/>
  <meta http-equiv="Cache-Control" content="no-siteapp">
  <meta name="theme-color" content="#1e2327">
  <link rel="apple-touch-icon" href="https://github.githubassets.com/apple-touch-icon.png">
  <link rel="apple-touch-icon" sizes="180x180" href="https://github.githubassets.com/apple-touch-icon-180x180.png">

  <link rel="icon" type="image/x-icon" href="https://github.githubassets.com/favicon.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="stylesheet"
        href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
  

  
<script>
  var _hmt = _hmt || [];
  (function(){var hm = document.createElement("script");
    hm.src = "//hm.baidu.com/hm.js?619384c7a8842a5937347674d96c7276";
    var s = document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm, s);})();
</script>


  <script src="//cdnjs.cloudflare.com/ajax/libs/vue/1.0.25-csp/vue.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/moment.js/2.11.2/moment.min.js"></script>
<meta name="generator" content="Hexo 4.2.1"></head>

<body id="replica-app">

<nav class="navbar-wrapper">
  <div class="navbar">
    <div class="container clearfix">
      <a href="/" class="navbar-logo"><i class="fa fa-github"></i></a>

      <div class="navbar-search float-left desktop-only">
        <div class="navbar-search-form">
          <label for="gsc-i-id1">This website</label>
          <div id="google-search">
            <gcse:search></gcse:search>
          </div>
        </div>
      </div>

      <ul class="navbar-nav float-left">
        
        <li><a href="/archives">Archives</a></li>
        
        
        <li><a href="/categories">Categories</a></li>
        
        
        <li><a href="/tags">Tags</a></li>
        
        
        <li class="desktop-only"><a href="/atom.xml" target="_blank">RSS</a></li>
        
      </ul>

      <ul class="navbar-nav user-nav float-right desktop-only">
        <li class="user-nav-notification">
          <a><span class="user-nav-unread"></span><i class="fa fa-bell"></i></a>
        </li>
        <li>
          <a><i class="fa fa-plus"></i> <i class="fa fa-caret-down"></i></a>
        </li>
        <li class="user-nav-logo">
          <a><img src="/images/header.jpg"> <i class="fa fa-caret-down"></i></i></a>
        </li>
      </ul>
    </div>
  </div>
</nav>

<div class="main-container">
  <header class="header-wrapper desktop-only">
  <div class="container header-site-detail">
    <ul class="header-toolbar">
      <li class="clearfix">
        <a href="/archives" class="header-toolbar-left"><i
                  class="fa fa-file-text"></i> Posts </a>
        <a href="/archives"
           class="header-toolbar-right"> 6 </a>
      </li>
      <li>
        <a href="/tags" class="header-toolbar-left"><i
                  class="fa fa-tags"></i> Tags </a>
        <a href="/tags"
           class="header-toolbar-right"> 9 </a>
      </li>
      <li>
        <a href="/categories" class="header-toolbar-left"><i
                  class="fa fa-folder-open"></i> Categories </a>
        <a href="/categories"
           class="header-toolbar-right"> 0 </a>
      </li>
    </ul>
    <h2 class="header-title">
      <i class="fa fa-book text-muted"></i>
      <a href="/">Guoer03的学习笔记</a>
      
      
    </h2>
  </div>

  <div class="container">
    <div class="header-tab-wrapper clearfix">
      <span class="header-tab header-tab-selected"><i class="fa fa-thumbs-o-up"></i> Like</span>
      <span class="header-tab"><i class="fa fa-share-alt"></i> Share</span>
      <span class="header-tab"><i class="fa fa-comments-o"></i> Discussion</span>
      <span class="header-tab"><i class="fa fa-bookmark-o"></i> Bookmark </span>
      <span class="header-tab"><i class="fa fa-smile-o"></i> Smile <i class="fa fa-caret-down"></i></span>
    </div>
  </div>
</header>


<div class="post-container container">
  <h3>
    <i class="fa fa-user-o"></i>
    Arthur Ming

    <span class="post-date float-right" title="{{moment(1593525339000).format('MMM DD, YYYY, h:mm:ss A')}}">
      
          <i class="fa fa-pencil-square-o"></i>
      
      {{moment(1593525339000).fromNow()}}
    </span>
  </h3>

  <article class="post-content">
    <h1>Redis底层原理剖析</h1>
    <h1 id="Redis基础数据结构"><a href="#Redis基础数据结构" class="headerlink" title="Redis基础数据结构"></a>Redis基础数据结构</h1><blockquote>
<p>Value的结构不一样<br>redis对象头：</p>
</blockquote>
<pre><code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RedisObject</span>&#123;</span></span><br><span class="line"> int4 type;<span class="comment">//4 bits </span></span><br><span class="line"> int4 encoding;<span class="comment">//4 bits</span></span><br><span class="line"> int24 lru;<span class="comment">//24bits</span></span><br><span class="line"> int32 refcount;<span class="comment">//4bytes</span></span><br><span class="line"> <span class="keyword">void</span> *ptr;<span class="comment">//8bytes,64-bit system,指向对象内容的具体存储位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h2 id="string（字符串）"><a href="#string（字符串）" class="headerlink" title="string（字符串）##"></a>string（字符串）##</h2><pre><code>动态字符串，相当于java中的ArrayList,但仅仅是动态上相似。</code></pre><p><strong>扩容规则：</strong><br>当字符串长度小于1M时，扩容是直接加倍现有空间，超过1M时一次只会多扩1M的空间，最大长度为512M  </p>
<p><strong>键值对 get set</strong> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">set</span> name codehole</span><br><span class="line">OK</span><br><span class="line">&gt; <span class="built_in">get</span> name</span><br><span class="line"><span class="string">"codehole"</span></span><br><span class="line">&gt; exits name</span><br><span class="line">(error) ERR unknown command 'exits'</span><br><span class="line">&gt; <span class="built_in">exists</span> name</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">&gt; del name</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">&gt; <span class="built_in">get</span> name</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>

<p><strong>批量键值对 mget  mset</strong>  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  &gt; mget name1 name2 name3 #返回一个链表</span><br><span class="line"><span class="number">1</span>) <span class="string">"codehole"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"holycoder"</span></span><br><span class="line"><span class="number">3</span>) (nil)</span><br><span class="line">&gt; mset name1 boy name2 girl name3 unknown</span><br><span class="line">OK</span><br><span class="line">&gt; mget name1 name2 name3</span><br><span class="line"><span class="number">1</span>) <span class="string">"boy"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"girl"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"unknown"</span></span><br></pre></td></tr></table></figure>


<p><strong>过期和set命令扩展</strong>  </p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    &gt; set name Aurthur</span><br><span class="line">    OK</span><br><span class="line">    &gt; get name</span><br><span class="line">    &quot;Aurthur&quot;</span><br><span class="line">    &gt; expire name 5</span><br><span class="line">    (integer) 1</span><br><span class="line">    &gt; get name</span><br><span class="line">    (nil)</span><br><span class="line">    &gt; setex name 5 Authur  #相当于set+expire</span><br><span class="line">    OK</span><br><span class="line">    &gt; get name</span><br><span class="line">    (nil)</span><br><span class="line">    &gt; setnx name codehole # 相当于set if not exists</span><br><span class="line">    (integer) 1</span><br><span class="line">    &gt; get name</span><br><span class="line">    &quot;codehole&quot;</span><br><span class="line">    &gt; setnx name Aurthur</span><br><span class="line">    (integer) 0</span><br><span class="line">	&#96;&#96;&#96;	</span><br><span class="line"></span><br><span class="line">**计数：如果value是个整数，还可以对它进行自增操作。**  </span><br><span class="line">&gt;自增范围：signed long的范围：[-2^31, 2^31-1]，超过这个值会报错</span><br></pre></td></tr></table></figure>
&gt; set age 30
OK
&gt; incr age
(integer) 31
&gt; incrby age 5
(integer) 36
&gt; incrby age -7
(integer) 29
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 字符串内部结构： ##</span><br><span class="line">Redis 的字符串叫着**「SDS」**，也就是 **Simple Dynamic String**。它的结构是一个带长度信息的字节数组。</span><br></pre></td></tr></table></figure>
struct SDS&lt;T&gt; {
    T capacity; // 数组容量，用泛型是因为为了节约内存，容量很小的时候用short和byte
    T len; // 数组长度
    T free;
    byte flags; // 特殊标识位，不理睬它
    byte[] content; // 数组内容
}  
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">其中SDS和C字符串的区别:  </span><br><span class="line">![](https:&#x2F;&#x2F;gitee.com&#x2F;guoer03&#x2F;picimg&#x2F;raw&#x2F;master&#x2F;clipboard.png) </span><br><span class="line"></span><br><span class="line">**长度很短的时候使用emb形式存储，当长度超过44时是用raw存储。**  </span><br><span class="line">![](https:&#x2F;&#x2F;gitee.com&#x2F;guoer03&#x2F;picimg&#x2F;raw&#x2F;master&#x2F;16760)  </span><br><span class="line">![](https:&#x2F;&#x2F;gitee.com&#x2F;guoer03&#x2F;picimg&#x2F;raw&#x2F;master&#x2F;16762)  </span><br><span class="line">有了raw后为什么还会有embstr的编码方式？  </span><br><span class="line">    </span><br><span class="line">因为embstr的编码方式有一些优点：  &#39;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. embstr将创建字符串对象所需的内存分配次数从raw编码的两次降低为一次 </span><br><span class="line">2. 释放embstr的字符串只需要调用一次内存释放函数，而释放raw编码的字符串对象需要调用两次内存释放函数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">----------</span><br><span class="line"></span><br><span class="line">## list（列表） ##</span><br><span class="line">	</span><br><span class="line">&gt;相当于java里的LinkedList--链表。当最后一个元素被弹出，list自动被删除，内存被回收  </span><br><span class="line"></span><br><span class="line">右边进左边出：队列</span><br></pre></td></tr></table></figure>
&gt; rpush books python java golang
(integer) 3
&gt; llen books
(integer) 3
&gt; lpop books
&quot;python&quot;
&gt; lpop books
&quot;java&quot;
&gt; lpop books
&quot;golang&quot;
&gt; exists books
(integer) 0  
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">右边进左边出：栈</span><br></pre></td></tr></table></figure>
&gt; rpush books python java golang
(integer) 3
&gt; rpop books
&quot;golang&quot;
&gt; rpop books
&quot;java&quot;
&gt; rpop books
&quot;python&quot;
&gt; rpop books
(nil)
&gt; exists books
(integer) 0  
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**慢操作**  </span><br><span class="line"></span><br><span class="line">- **lindex**相当于Java链表中的get(int index)方法,时间复杂度O(n)</span><br><span class="line">- **ltrim**两个参数start_index和end_index定义了一个区间，其他的都删掉  </span><br><span class="line">- **index**可以为负数，-1位倒数第一个元素  </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">----------</span><br></pre></td></tr></table></figure>
&gt; rpush books python java golang  
(integer) 3  
&gt; lindex books 1  
&quot;java&quot;  
&gt; lrange books 0 -1  
1) &quot;python&quot;  
2) &quot;java&quot;  
3) &quot;golang&quot;  
&gt; ltrim books 1 0  
OK  
&gt; exists books  
(integer) 0  
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**list的具体实现：**</span><br><span class="line">![](https:&#x2F;&#x2F;gitee.com&#x2F;guoer03&#x2F;picimg&#x2F;raw&#x2F;master&#x2F;clipboard%20(3).png)  </span><br><span class="line">元素较少时：是用ziplist，紧挨在一起。</span><br></pre></td></tr></table></figure>
127.0.0.1:6379&gt; rpush books java python cpp golang
(integer) 4
127.0.0.1:6379&gt; debug object books
Value at:00007FF1070027C0 refcount:1 encoding:ziplist serializedlength:39 lru:15949445 lru_seconds_idle:14  
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">当数据量很多时---**quicklist**，普通链表需要的指针占用太大空间，会加重内存的碎片化。quicklist里的每个ziplist都有一个prev和next指针。  </span><br><span class="line"></span><br><span class="line">**压缩列表：**  </span><br><span class="line">![](https:&#x2F;&#x2F;gitee.com&#x2F;guoer03&#x2F;picimg&#x2F;raw&#x2F;master&#x2F;clipboard%20(4).png) </span><br><span class="line"> </span><br><span class="line">	&#96;&#96;&#96;C</span><br><span class="line">    struct ziplist&lt;T&gt;&#123;</span><br><span class="line">	    int32 zlbytes;&#x2F;&#x2F;整个压缩列表占用字节数</span><br><span class="line">	    int32 zltail_offset;&#x2F;&#x2F;最后一个元素距离列表起始位置的偏移量，用于快速定位到最后一个节点</span><br><span class="line">	    int16 zllength;&#x2F;&#x2F;元素个数</span><br><span class="line">	    T[] entries;&#x2F;&#x2F;元素内容列表，挨个挨个紧凑存储</span><br><span class="line">	    int8 zlend;&#x2F;&#x2F;标志压缩列表的结束，值恒为0xFF</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></code></pre><hr>
<pre><code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">entry</span>&#123;</span></span><br><span class="line"> <span class="keyword">int</span>&lt;var&gt; prelen<span class="comment">//前一个entry的字节长度</span></span><br><span class="line"> <span class="keyword">int</span>&lt;var&gt; encoding; <span class="comment">// 元素类型编码</span></span><br><span class="line"> optional <span class="keyword">byte</span>[] content; <span class="comment">// 元素内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>它的 <strong>prevlen</strong> 字段表示前一个 entry 的字节长度，当压缩列表倒着遍历时，需要通过这个字段来快速定位到下一个元素的位置。它是一个变长的整数，当字符串长度小于254(0xFE) 时，使用一个字节表示；如果达到或超出 254(0xFE) 那就使用 5 个字节来表<br>示。  </p>
<p><strong>快速列表：</strong><br><img src="https://gitee.com/guoer03/picimg/raw/master/clipboard%20(5).png" alt="">  </p>
<pre><code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> &#123;</span></span><br><span class="line"> quicklistNode* prev;</span><br><span class="line"> quicklistNode* next;</span><br><span class="line"> ziplist* zl; <span class="comment">// 指向压缩列表</span></span><br><span class="line"> int32 <span class="built_in">size</span>; <span class="comment">// ziplist 的字节总数</span></span><br><span class="line"> int16 count; <span class="comment">// ziplist 中的元素数量</span></span><br><span class="line"> int2 encoding; <span class="comment">// 存储形式 2bit，原生字节数组还是 LZF 压缩存储</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">quicklist</span> &#123;</span></span><br><span class="line"> quicklistNode* head;</span><br><span class="line"> quicklistNode* tail;</span><br><span class="line"> <span class="keyword">long</span> count; <span class="comment">// 元素总数</span></span><br><span class="line"> <span class="keyword">int</span> nodes; <span class="comment">// ziplist 节点的个数</span></span><br><span class="line"> <span class="keyword">int</span> compressDepth; <span class="comment">// LZF 算法压缩深度</span></span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p><strong>每个ziplist存多少元素？</strong>   </p>
<blockquote>
<p>quicklist 内部默认单个 ziplist 长度为 8k 字节，超出了这个字节数，就会新起一个<br>ziplist。ziplist 的长度由配置参数 list-max-ziplist-size 决定。  </p>
</blockquote>
<p><strong>压缩深度:</strong>    </p>
<blockquote>
<p>quicklist 默认的压缩深度是 0，也就是不压缩。压缩的实际深度由配置参数 list compress-depth 决定。为了支持快速的 push/pop 操作，quicklist 的首尾两个 ziplist 不压缩，此时深度就是 1。如果深度为 2，就表示 quicklist 的首尾第一个 ziplist 以及首尾第二个 ziplist 都不压缩。  </p>
</blockquote>
<hr>
<h2 id="hash（字典）"><a href="#hash（字典）" class="headerlink" title="hash（字典）"></a>hash（字典）</h2><blockquote>
<p>相当于HashMap,无序字典。不同于java中hashMap的是，值只能是字符串，都是用拉链法处理冲突。  </p>
</blockquote>
<p>rehash操作有所不同：先看hashmap中的rehash：<strong>一次性全部rehash</strong><br><img src="https://gitee.com/guoer03/picimg/raw/master/clipboard%20(6).png" alt="">  </p>
<p>而redis为了性能，不堵塞服务，采用了<strong>渐进式hash策略</strong>：  </p>
<p><img src="https://gitee.com/guoer03/picimg/raw/master/clipboard%20(7).png" alt=""><br>渐进式 rehash 会在 rehash 的同时，保留新旧两个 hash 结构，查询时会同时查询两个hash 结构，然后后续循序渐进地将旧 hash 的内容一点点迁移到新的 hash 结构中。</p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt; hset books java &quot;think in java&quot; # 命令行的字符串如果包含空格，要用引号括起来</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; hset books golang &quot;concurrency in go&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; hset books python &quot;python cookbook&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; hgetall books # entries()，key 和 value 间隔出现</span><br><span class="line">1) &quot;java&quot;</span><br><span class="line">2) &quot;think in java&quot;</span><br><span class="line">3) &quot;golang&quot;</span><br><span class="line">4) &quot;concurrency in go&quot;</span><br><span class="line">5) &quot;python&quot;</span><br><span class="line">6) &quot;python cookbook&quot;</span><br><span class="line">&gt; hlen books</span><br><span class="line">(integer) 3</span><br><span class="line">&gt; hget books java</span><br><span class="line">&quot;think in java&quot;</span><br><span class="line">&gt; hset books golang &quot;learning go programming&quot; # 因为是更新操作，所以返回 0</span><br><span class="line">(integer) 0</span><br><span class="line">&gt; hget books golang &quot;learning go programming&quot;</span><br><span class="line">&gt; hmset books java &quot;effective java&quot; python &quot;learning python&quot; golang &quot;modern golang</span><br><span class="line">programming&quot; # 批量 set</span><br><span class="line">OK</span><br></pre></td></tr></table></figure></code></pre><p><strong>hash表-内部结构：</strong><br><img src="https://gitee.com/guoer03/picimg/raw/master/clipboard%20(8).png" alt=""><br><strong>hash函数：</strong>siphash：即使在输入key很小的情况下，也可以产生随机性特别好的输出  </p>
<p><strong>hash攻击：</strong>hash函数如果具有偏向性，黑客就可能利用偏向性对服务器进行攻击，因为这样的hash函数会导致hash第二维链表长度极为不均匀，甚至所有的计算元素集中到个别链表中</p>
<p>扩容条件：当hash表中元素等于第一维数组的长度时就会开始扩容，新数组是原来的两倍，如果Redis正在bgsave，就尽量不扩容，但是hash表元素个数如果达到了第一维数组的五倍以上，就会强制扩容</p>
<p><strong>缩容条件：</strong>元素个数低于数组长度的10%，缩容时不会考虑Redis是否在做bgsave。</p>
<p>set的结构底层也是字典，不过所有的value全部都是null，java 中set底层由hashmap实现，元素全部作为key，value为null，则可达到自动去重。             </p>
<hr>
<h2 id="zset-有序列表"><a href="#zset-有序列表" class="headerlink" title="zset(有序列表)"></a>zset(有序列表)</h2><blockquote>
<p>根据score对value进行排序： zset 可以用来存粉丝列表，value 值是粉丝的用户 ID，score 是关注时间。我们可以对粉丝列表按关注时间进行排序。  </p>
</blockquote>
<p>语法：    </p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&gt; zadd books 9.0 &quot;think in java&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; zadd books 8.9 &quot;java concurrency&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; zadd books 8.6 &quot;java cookbook&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; zrange books 0 -1 # 按 score 排序列出，参数区间为排名范围</span><br><span class="line">1) &quot;java cookbook&quot;</span><br><span class="line">2) &quot;java concurrency&quot;</span><br><span class="line">3) &quot;think in java&quot;</span><br><span class="line">&gt; zrevrange books 0 -1 # 按 score 逆序列出，参数区间为排名范围</span><br><span class="line">1) &quot;think in java&quot;</span><br><span class="line">2) &quot;java concurrency&quot;</span><br><span class="line">3) &quot;java cookbook&quot;</span><br><span class="line">&gt; zcard books # 相当于 count()</span><br><span class="line">(integer) 3</span><br><span class="line">&gt; zscore books &quot;java concurrency&quot; # 获取指定 value 的 score</span><br><span class="line">&quot;8.9000000000000004&quot; # 内部 score 使用 double 类型进行存储，所以存在小数点精度问题</span><br><span class="line">&gt; zrank books &quot;java concurrency&quot; # 排名</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; zrangebyscore books 0 8.91 # 根据分值区间遍历 zset</span><br><span class="line">1) &quot;java cookbook&quot;</span><br><span class="line">2) &quot;java concurrency&quot;</span><br><span class="line">&gt; zrangebyscore books -inf 8.91 withscores # 根据分值区间 (-∞, 8.91] 遍历 zset，同时返</span><br><span class="line">回分值。inf 代表 infinite，无穷大的意思。</span><br><span class="line">1) &quot;java cookbook&quot;</span><br><span class="line">2) &quot;8.5999999999999996&quot;</span><br><span class="line">3) &quot;java concurrency&quot;</span><br><span class="line">4) &quot;8.9000000000000004&quot;</span><br><span class="line">&gt; zrem books &quot;java concurrency&quot; # 删除 value</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; zrange books 0 -1</span><br><span class="line">1) &quot;java cookbook&quot;</span><br><span class="line">2) &quot;think in java&quot;</span><br></pre></td></tr></table></figure></code></pre><p><strong>跳跃列表：</strong><br><img src="https://gitee.com/guoer03/picimg/raw/master/clipboard%20(9).png" alt="">  </p>
<p><strong>查找步骤：</strong><br>    查找的步骤是从头节点的顶层开始，查到第一个大于指定元素的节点时，退回上一节点，在下一层继续查找。<br>例如我们要在上面的列表中查询16。</p>
<ul>
<li>从头节点的最顶层开始，先到节点7。</li>
<li>7的下一个节点是39，大于16，因此我们退回到7</li>
<li>从7开始，在下一层继续查找，就可以找到16。  </li>
</ul>
<p><strong>插入过程：</strong><br>     在搜索合适插入点的过程中将「搜索路径」摸出来了，然后就可以开始创建新节点了，创建的时候需要给这个节点随机分配一个层数，再将搜索路径上的节点和这个新节点通过前向后向指针串起来。如果分配的新节点的高度高于当前跳跃列表的最大高度，就需要更新一下跳跃列表的最大高度。  </p>
<blockquote>
<p>定义了两个数组，update数组用来存储搜索路径，rank数组用来存储节点跨度。<br>第一步操作是找出要插入节点的搜索路径，并且记录节点跨度数。<br>接着开始插入，先随机一个层数。如果随机出的层数大于当前的层数，就需要继续填充update和rank数组，并更新skiplist的最大层数。<br>然后调用zslCreateNode函数创建新的节点。<br>创建好节点后，就根据搜索路径数据提供的位置，从第一层开始，逐层插入节点（更新指针），并其他节点的span值。<br>最后还要更新回溯节点，以及将skiplist的长度加一。<br>这就是插入新元素的整个过程。   </p>
</blockquote>
<p><strong>随机层数的计算过程如下：</strong>  </p>
<blockquote>
<p>相当于做一次丢硬币的实验，如果遇到正面，继续丢，遇到反面，则停止。各个元素的层数，期望值是2层。  </p>
</blockquote>
<p><strong>更新过程：</strong><br>当对应的value不存在，就直接插入，如果value存在并且score更新后并没有改变排列顺序，则直接更新score的值，如果排序会发生改变，则直接删除再插入  </p>
<p><strong>如果 score 值都一样：</strong>  </p>
<blockquote>
<p>zset 中所有的 score 值都是一样的，zset 的查找性能会退化为<br>O(n) 么？Redis 作者自然考虑到了这一点，所以 zset 的排序元素不只看 score 值，如果score 值相同还需要再比较 value 值 (字符串比较)。  </p>
</blockquote>
<p><strong>元素排名：</strong><br>  给每一个 forward 指针都增加了 span 属性，span 是「跨度」的意思，表示从前一个节点沿着当前层的 forward 指针跳到当前这个节点中间会跳过多少个节点。<br>    <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zslforward</span> &#123;</span></span><br><span class="line">	    zslnode* item;</span><br><span class="line">	    <span class="keyword">long</span> span; <span class="comment">// 跨度</span></span><br><span class="line">    &#125;</span><br><span class="line">	```  </span><br><span class="line">&gt; 这样当我们要计算一个元素的排名时，只需要将「搜索路径」上的经过的所有节点的跨度 span 值进行叠加就可以算出元素的最终 rank 值。   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">----------</span><br><span class="line">## HyperLogLog: ##</span><br><span class="line">&gt;提供不精确的去重计数方案</span><br></pre></td></tr></table></figure><br>    127.0.0.1:6379&gt; pfadd codehole user1<br>    (integer) 1<br>    127.0.0.1:6379&gt; pfcount codehole<br>    (integer) 1<br>    127.0.0.1:6379&gt; pfadd codehole user2<br>    (integer) 1<br>    127.0.0.1:6379&gt; pfcount codehole<br>    (integer) 2<br>    127.0.0.1:6379&gt; pfadd codehole user3<br>    (integer) 1<br>    127.0.0.1:6379&gt; pfcount codehole<br>    (integer) 3<br>    127.0.0.1:6379&gt; pfadd codehole user4<br>    (integer) 1<br>    127.0.0.1:6379&gt; pfcount codehole<br>    (integer) 4<br>    127.0.0.1:6379&gt; pfadd codehole user5<br>    (integer) 1<br>    127.0.0.1:6379&gt; pfcount codehole<br>    (integer) 5<br>    127.0.0.1:6379&gt; pfadd codehole user6<br>    (integer) 1<br>    127.0.0.1:6379&gt; pfcount codehole<br>    (integer) 6<br>    127.0.0.1:6379&gt; pfadd codehole user7 user8 user9 user10<br>    (integer) 1<br>    127.0.0.1:6379&gt; pfcount codehole<br>    (integer) 10</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">**pfmerge:**在网站中我们有两个内容差不多的页面，运营说需要这两个页面的数据进行合并。其中页面的 UV 访问量也需要合并，那这个时候 pfmerge 就可以派上用场了。  </span><br><span class="line"></span><br><span class="line">**注意事项**：hyperLogLog在计数很小的时候，采用稀疏矩阵存储，计数慢慢变大使得稀疏矩阵所用空间超过阈值时才会转变成稠密矩阵，才会占用12k空间。  </span><br><span class="line"></span><br><span class="line">**HyperLogLog的概率学证明：**  </span><br><span class="line">![](https:&#x2F;&#x2F;gitee.com&#x2F;guoer03&#x2F;picimg&#x2F;raw&#x2F;master&#x2F;20200701233939.png)  </span><br><span class="line">但是当统计数据量很小的时候误差较大，故采用调和平均数</span><br><span class="line">调和平均数可以过滤掉异常离群点。    </span><br><span class="line">HyperLogLog原理：分了很多个桶，它的实现中，设有 16384 个桶，即：2^14 &#x3D; 16384，每个桶有 6 位，每个桶可以表达的最大数字是：25+24+...+1 &#x3D; 63 ，二进制为： 111 111 。 </span><br><span class="line"> </span><br><span class="line">对于命令：pfadd key value  </span><br><span class="line">在存入时，value 会被 hash 成 64 位，即 64 bit 的比特字符串，前 14 位用来选择这个 value 的比特串中从右往左第一个 1 出现的下标位置数值要存到那个桶中去，即前 14 位用来分桶。设第一个1出现位置的数值为 index 。当 index&#x3D;5 时，就是: ....10000 [01 0000 0000 0000]</span><br><span class="line">之所以选 14位 来表达桶编号是因为，分了 16384 个桶，而 2^14 &#x3D; 16384，刚好地，最大的时候可以把桶利用完，不造成浪费。假设一个字符串的前 14 位是：00 0000 0000 0010 (从右往左看) ，其十进制值为 2。那么 index 将会被转化后放到编号为 2 的桶。  </span><br><span class="line">index 的转化规则：  </span><br><span class="line">首先因为完整的 value 比特字符串是 64 位形式，减去 14 后，剩下 50 位，那么极端情况，出现 1 的位置，是在第 50 位，即位置是 50。此时 index &#x3D; 50。此时先将 index 转为 2 进制，它是：110010 。  </span><br><span class="line">因为16384 个桶中，每个桶是 6 bit 组成的。刚好 110010 就被设置到了第 2 号桶中去了。请注意，50 已经是最坏的情况，且它都被容纳进去了。那么其他的不用想也肯定能被容纳进去。  </span><br><span class="line">因为 fpadd 的 key 可以设置多个 value。例如下面的例子：</span><br><span class="line"></span><br><span class="line">	&#96;&#96;&#96; </span><br><span class="line">    pfadd lgh golang  </span><br><span class="line">    pfadd lgh python  </span><br><span class="line">    pfadd lgh java</span><br></pre></td></tr></table></figure>

<p>根据上面的做法，不同的 value，会被设置到不同桶中去，如果出现了在同一个桶的，即前 14 位值是一样的，但是后面出现 1 的位置不一样。那么比较原来的 index 是否比新 index 大。是，则替换。否，则不变。<br>最终地，一个 key 所对应的 16384 个桶都设置了很多的 value 了，每个桶有一个k_max。此时调用 pfcount 时，按照前面介绍的估算方式，便可以计算出 key 的设置了多少次 value，也就是统计值。<br>value 被转为 64 位的比特串，最终被按照上面的做法记录到每个桶中去。64 位转为十进制就是：2^64，HyperLogLog 仅用了：16384 * 6 /8 / 1024 K （12k）存储空间就能统计多达 2^64 个数。  </p>
<hr>
<h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><p><strong>应用场景</strong>：用来判断某个value是否已经存在缓存当中，新闻推荐，不给用户推荐已经看过的新闻  </p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; bf.add codehole user1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; bf.add codehole user2</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; bf.add codehole user3</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; bf.exists codehole user1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; bf.exists codehole user2</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; bf.exists codehole user3</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; bf.exists codehole user4</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; bf.madd codehole user4 user5 user6</span><br><span class="line">1) (integer) 1</span><br><span class="line">2) (integer) 1</span><br><span class="line">3) (integer) 1</span><br><span class="line">127.0.0.1:6379&gt; bf.mexists codehole user4 user5 user6 user7</span><br><span class="line">1) (integer) 1</span><br><span class="line">2) (integer) 1</span><br><span class="line">3) (integer) 1</span><br><span class="line">4) (integer) 0</span><br></pre></td></tr></table></figure></code></pre><p>对于见过的元素肯定不会误判，对于没见过的元素，有可能会认为已经存在了<br><img src="https://gitee.com/guoer03/picimg/raw/master/20200701234300.png" alt=""><br><img src="https://gitee.com/guoer03/picimg/raw/master/20200701234312.png" alt="">  </p>
<p>随着元素存储越来越多，那么都会变成1，最后再来啥元素都会判定已经存在了。</p>
<p><strong>如何选择哈希函数个数和布隆过滤器长度</strong><br><img src="https://gitee.com/guoer03/picimg/raw/master/20200701234345.png" alt=""><br>k 为哈希函数个数，m 为布隆过滤器长度，n 为插入的元素个数，p 为误报率。</p>
<hr>
<h2 id="Redis使用场景"><a href="#Redis使用场景" class="headerlink" title="Redis使用场景"></a>Redis使用场景</h2><p><strong>计数器</strong><br>可以对string进行自增自减运算，实现计数器功能<br>读写性能非常好，很适合存储频繁读写的计数量  </p>
<p><strong>缓存</strong><br>将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率  </p>
<p><strong>查找表</strong><br>例如DNS记录就很适合使用Redis进行存储<br>查找表和缓存类似，也是利用了Redis快速查找特性，但是查找表的内容不能失效  </p>
<p><strong>消息队列</strong><br>List是一个双向链表，可以通过Lpush和rpop写入和读取消息，不过最好使用消息中间件  </p>
<p><strong>会话缓存</strong><br>可以使用Redis统一存储多台应用服务器的会话信息。当应用服务器不再存储用户的会话信息，也就不再具有状态  </p>
<p><strong>其他</strong><br>Set可以实现交集，并集等操作。从而实现共同好友等功能。<br>ZSet可以实现有序性操作，实现排行榜功能。</p>
<hr>
<h2 id="Redis和Memcached"><a href="#Redis和Memcached" class="headerlink" title="Redis和Memcached"></a>Redis和Memcached</h2><p><strong>数据类型</strong>  </p>
<p>  Memcached仅支持字符串类型，而Redis支持五种不同的数据类型。<br><strong>数据持久化</strong>  </p>
<p> Redis支持两种持久化策略：RDB快照和AOF日志，而Memcached不支持持久化。<br><strong>分布式</strong>  </p>
<p>  Memcached不支持分布式，只能通过客户端使用一致性哈希来实现分布式存储，这种方式在存储和查询时都需要先在客户端计算一次数据所在的节点  </p>
<p>Redis Cluster实现了分布式的支持<br><strong>内存管理机制</strong>  </p>
<p>   在Redis中，并不是所有数据都一直存储在内存中，可以将一些很久没用的value交换到磁盘，而Memcached的数据则会一直在内存中。</p>
<p>Memcached将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题，但是会使内存利用率不高   </p>
<hr>
<h2 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h2><p><strong>RDB快照</strong><br>RDB是一种快照存储持久化方式，具体就是将Redis某一时刻的内存数据保存到硬盘的文件当中，默认保存的文件名为dump.rdb，而在Redis服务器启动时，会重新加载dump.rdb文件的数据到内存当中恢复数据。如果数据量很大，保存快照的时间会很长  </p>
<p><strong>AOF日志</strong><br>AOF只记录对内存进行修改的指令记录。<br>假设 AOF 日志记录了自 Redis 实例创建以来所有的修改性指令序列，那么就可以通过对一个空的 Redis 实例顺序执行所有的指令，也就是「重放」，来恢复 Redis 当前实例的内存数据结构的状态。</p>
<p>Redis 在长期运行的过程中，AOF 的日志会越变越长。如果实例宕机重启，重放整个AOF 日志会非常耗时，导致长时间 Redis 无法对外提供服务。所以需要对 AOF 日志瘦身。  </p>
<hr>
<h2 id="数据淘汰策略"><a href="#数据淘汰策略" class="headerlink" title="数据淘汰策略"></a>数据淘汰策略</h2><p>可以设置内存最大使用量，当内存使用量超出时，会施行数据淘汰策略。<br>Redis具体有6种淘汰策略：<br><img src="https://gitee.com/guoer03/picimg/raw/master/20200701234847.png" alt="">  </p>
<p>作为内存数据库，出于对性能和内存消耗的考虑，Redis的淘汰算法实际上并非针对所有key，而是抽样一小部分并且从中选出被淘汰的key。  </p>
<p>为了提高缓存命中率，需要保证缓存数据都是热点数据，可以将内存最大使用量设置为热点数据占用的内存量，然后启用allkeys-lru淘汰策略，将最近最少使用的数据淘汰。</p>
<hr>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p><strong>基本使用：</strong><br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; multi</span><br><span class="line">OK</span><br><span class="line">&gt; incr books</span><br><span class="line">QUEUED #表示指令已经被服务器缓存到队列里了</span><br><span class="line">&gt; incr books</span><br><span class="line">QUEUED</span><br><span class="line">&gt; exec</span><br><span class="line">(integer) 1</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure><br>所有的指令在exec之前不执行，而是缓存在服务器的一个事务队列中，服务器一旦收到exec指令，才开始执行整个事务队列，执行完毕一次性返回所有指令的运行结果。</p>
<p>Redis事务不支持原子性只是保证了事务的隔离性：实验如下<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set books iamastring</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; incr books</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; set poorman iamdesperate</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; exec</span><br><span class="line">1) OK</span><br><span class="line">2) (error) ERR value is not an integer or out of range</span><br><span class="line">3) OK</span><br><span class="line">127.0.0.1:6379&gt; get poorman</span><br><span class="line">&quot;iamdesperate&quot;</span><br><span class="line">127.0.0.1:6379&gt; get books</span><br><span class="line">&quot;iamastring&quot;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><blockquote>
<p>Redis服务器是一个事件驱动程序。   </p>
</blockquote>
<p><strong>文件事件</strong><br>服务器通过套接字与客户端或者其它服务器进行通信，文件事件就是对套接字操作的抽象。 </p>
<p>Redis <strong>基于 Reactor 模式</strong>开发了自己的网络事件处理器，使用 I/O 多路复用程序来同时监听多个套接字，并将到达的<br>事件传送给文件事件分派器，分派器会根据套接字产生的事件类型调用相应的事件处理器。<br><img src="https://gitee.com/guoer03/picimg/raw/master/20200701235037.png" alt="">  </p>
<p><strong>时间事件</strong><br>服务器有一些操作需要在给定的时间点执行，时间事件是对这类定时操作的抽象  </p>
<p><strong>定时事件</strong>：让一段程序在指定的时间内执行一次<br><strong>周期性事件</strong>：每隔指定时间就执行一次<br>Redis将所有的时间事件都放在一个无序链表中，通过遍历整个链表查找出已到达的时间事件，并调用相应的事件处理器。<br><strong>事件的调度与执行</strong><br>服务器需要不断监听文件事件的套接字才能得到待处理的文件事件，但是不能一直监听，否则时间事件无法在规定的时间内执行，因此监听时间应该根据距离现在最近的时间事件来决定。<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">aeProcessEvents</span><span class="params">()</span>:</span></span><br><span class="line"> <span class="comment"># 获取到达时间离当前时间最接近的时间事件</span></span><br><span class="line"> time_event = aeSearchNearestTimer()</span><br><span class="line"> <span class="comment"># 计算最接近的时间事件距离到达还有多少毫秒</span></span><br><span class="line"> remaind_ms = time_event.when - unix_ts_now()</span><br><span class="line"> <span class="comment"># 如果事件已到达，那么 remaind_ms 的值可能为负数，将它设为 0</span></span><br><span class="line"> <span class="keyword">if</span> remaind_ms &lt; <span class="number">0</span>:</span><br><span class="line"> remaind_ms = <span class="number">0</span></span><br><span class="line"> <span class="comment"># 根据 remaind_ms 的值，创建 timeval</span></span><br><span class="line"> timeval = create_timeval_with_ms(remaind_ms)</span><br><span class="line"> <span class="comment"># 阻塞并等待文件事件产生，最大阻塞时间由传入的 timeval 决定</span></span><br><span class="line"> aeApiPoll(timeval)</span><br><span class="line"> <span class="comment"># 处理所有已产生的文件事件</span></span><br><span class="line"> procesFileEvents()</span><br><span class="line"> <span class="comment"># 处理所有已到达的时间事件</span></span><br><span class="line"> processTimeEvents()</span><br></pre></td></tr></table></figure><br>从事件处理的角度看服务器的执行流程：<br><img src="https://gitee.com/guoer03/picimg/raw/master/20200701235135.png" alt="">  </p>
<hr>
<h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>使用slaveof host port命令来让一个服务器成为另一个服务器的从服务器<br>**<br>支持主从复制和从从复制**</p>
<p><strong>CAP原理：</strong>网络分区发生时，一致性和可用性两难全  </p>
<p><strong>网络分区：</strong>例如两台分布式系统中的机器节点之间的网络断开了</p>
<p><strong>最终一致：</strong><br>    Redis的主从数据是异步同步的，所以分布式的Redis系统并不满足一致性要求。当客户端在Redis的主节点修改了数据以后，立即返回，即使在主从网络断开的情况下，主节点依旧可以正常对外提供修改服务，所以Redis满足可用性。<br>    但是Redis保证最终一致性，从节点会追赶主节点，最终从节点的状态会和主节点保持一致。如果网络断开了，主从节点的数据将会出现大量不一致，一旦网络恢复，从节点会采用多种策略努力追赶上落后的数据，继续尽力保持和主节点一致。  </p>
<p><strong>主从同步：</strong>  </p>
<p>  <strong>增量同步：</strong><br>Redis 同步的是指令流，主节点会将那些对自己的状态产生修改性影响的指令记录在本地的内存 buffer 中，然后异步将 buffer 中的指令同步到从节点，从节点一边执行同步的指令流来达到和主节点一样的状态，一遍向主节点反馈自己同步到哪里了 (偏移量)。<br>因为内存的 buffer 是有限的，所以 Redis 主库不能将所有的指令都记录在内存 buffer<br>中。Redis 的复制内存 buffer 是一个定长的环形数组，如果数组内容满了，就会从头开始覆盖前面的内容。如果因为网络状况不好，从节点在短时间内无法和主节点进行同步，那么当网络状况恢复时，Redis 的主节点中那些没有同步的指令在 buffer 中有可能已经被后续的指令覆盖掉了，从节点将无法直接通过指令流来进行同步，这个时候就需要用到更加复杂的同步机制 — 快照同步。 </p>
<p><strong>快照同步：</strong><br>快照同步是一个非常耗费资源的操作，它首先需要在主库上进行一次 bgsave 将当前内存的数据全部快照到磁盘文件中，然后再将快照文件的内容全部传送到从节点。从节点将快照文件接受完毕后，立即执行一次全量加载，加载之前先要将当前内存的数据清空。加载完毕后通知主节点继续进行增量同步。在整个快照同步进行的过程中，主节点的复制 buffer 还在不停的往前移动，如果快照同步的时间过长或者复制 buffer 太小，都会导致同步期间的增量指令在复制 buffer 中被覆盖，这样就会导致快照同步完成后无法进行增量复制，然后会再次发起快照同步，如此极有可能会陷入快照同步的死循环。  </p>
<p>所以务必配置一个合适的复制 buffer 大小参数，避免快照复制的死循环。</p>
<hr>
<h2 id="Sentinel-–哨兵"><a href="#Sentinel-–哨兵" class="headerlink" title="Sentinel –哨兵"></a>Sentinel –哨兵</h2><p><img src="https://gitee.com/guoer03/picimg/raw/master/20200701235341.png" alt="">  </p>
<p>我们可以将 Redis Sentinel 集群看成是一个 ZooKeeper 集群，它是集群高可用的心脏，它一般是由 3～5 个节点组成，这样挂了个别节点集群还可以正常运转。它负责持续监控主从节点的健康，当主节点挂掉时，自动选择一个最优的从节点切换为主节点。客户端来连接集群时，会首先连接 sentinel，通过 sentinel 来查询主节点的地址，然后再去连接主节点进行数据交互。当主节点发生故障时，客户端会重新向 sentinel 要地址，sentinel 会将最新的主节点地址告诉客户端。如此应用程序将无需重启即可自动完成节点切换。<br><img src="https://gitee.com/guoer03/picimg/raw/master/20200701235401.png" alt="">  </p>
<p>主节点挂掉了，原先的主从复制也断开了，客户端和损坏的主节点也断开了。从节点被提升为新的主节点，其它从节点开始和新的主节点建立复制关系。客户端通过新的主节点继续进行交互。Sentinel 会持续监控已经挂掉了主节点，待它恢复后，集群会调整为下面这张图。<br><img src="https://gitee.com/guoer03/picimg/raw/master/20200701235423.png" alt="">  </p>
<hr>
<h2 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h2><p><strong>客户端分片</strong>客户端使用一致性哈希等算法决定键应该分布到哪个节点上<br><strong>代理分片</strong>：将客户端请求发送到代理上，由代理转发请求到正确的节点上<br><strong>服务器分片</strong>：Redis Cluster  </p>

  </article>
</div>


    




</div>

<div class="footer-wrapper container">
  <footer class="footer clearfix">
    <div class="clearfix">
    <a href="http://guoer03.xyz" class="footer-logo">
      <i class="fa fa-github"></i>
    </a>
    <ul class="footer-social-link">
      <li>© 2020 Arthur Ming</li>
      <li><a href="http://guoer03.xyz">Home</a></li>
      
    </ul>
    <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
 
    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <div class="footer-theme-info">
      MingHai ❤ Love My girl gl
    </div>
    </div>
    
  </footer>
</div>




<script src="/js/main.js"></script>

</body>
</html>
